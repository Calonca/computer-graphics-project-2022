#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;layout(binding = 1) uniform sampler2D texSampler;layout(binding = 2) uniform GlobalUniformBufferObject {	vec3 lightDir;	vec4 lightColor;	vec3 eyePos;	vec3 leftSpotlightDir;	vec3 leftSpotlightPos;	vec3 leftSpotlightColor;	vec4 leftSpotlightParams;	vec3 rightSpotlightDir;	vec3 rightSpotlightPos;	vec3 rightSpotlightColor;	vec4 rightSpotlightParams;} gubo;float rayMarchShadows(vec3 ro, vec3 rd, float mint, float maxt, vec3 normal) {	// offset ro.y by a small epsilon to handle shadow acne	float epsilon = 0.025;	ro = ro + normal * epsilon;	float originalH = ro.y;	for(float t = mint; t < maxt;) {		// travel along rd by t		vec3 newPos = ro + t * rd;		float newH = 0;		if(newH > newPos.y) {			return 0.1;		}		if(t < 5.0 * mint) {			t += mint;		} else {			t += 2.0;		}		}	return 1.0;}float dotZeroOne(vec3 v1,vec3 v2){	return clamp(dot(v1,v2),0,1);}vec3 spot_light_dir(vec3 fragPosition,vec3 lightPos) {	vec3 surfaceToLight = lightPos - fragPosition;	return normalize(surfaceToLight);}vec3 spot_light_color(vec3 fragPosition,vec3 lightDir,vec3 lightPos,vec3 lightColor,vec4 lightParameters) {	vec3 d = lightDir;	float beta = lightParameters.z;	float g = lightParameters.w;	float cosIn = lightParameters.x;	float cosOut = lightParameters.y;	vec3 surfaceToLight = lightPos - fragPosition;	float decay = pow(g/length(surfaceToLight),beta);	decay = clamp(decay, 0, 1);	float coneDimming = (dot(spot_light_dir(fragPosition,lightPos),d)-cosOut)	/	(cosIn-cosOut);	coneDimming = clamp(coneDimming,0,1);	return decay*coneDimming*lightColor;}vec3 Lambert_Diffuse_BRDF(vec3 L, vec3 N, vec3 V, vec3 C) {	// Lambert Diffuse BRDF model	// in all BRDF parameters are:	// vec3 L : light direction	// vec3 N : normal vector	// vec3 V : view direction	// vec3 C : main color (diffuse color, or specular color)	float refFactor = dotZeroOne(N,L);	return C*refFactor;}float fog(float density){	const float LOG2 = -1.442695;	float dist = gl_FragCoord.z / gl_FragCoord.w * 0.1;	float d = density * dist;	return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);}void main() {	vec3 Norm =normalize(fragNorm);	vec3 EyeDir = normalize(gubo.eyePos - fragPos);	float occ = rayMarchShadows(fragPos, normalize(gubo.lightDir), 0.1, 30, Norm);	vec3 leftLightDir = spot_light_dir(fragPos,gubo.leftSpotlightPos);//Light direction for each pixel	vec3 leftLightColor = spot_light_color(fragPos,gubo.leftSpotlightDir,gubo.leftSpotlightPos,gubo.leftSpotlightColor,gubo.leftSpotlightParams);//Light color for each pixel	vec3 rightLightDir = spot_light_dir(fragPos,gubo.rightSpotlightPos);//Light direction for each pixel	vec3 rightLightColor = spot_light_color(fragPos,gubo.rightSpotlightDir,gubo.rightSpotlightPos,gubo.rightSpotlightColor,gubo.rightSpotlightParams);//Light color for each pixel	float AmbientFact = 0.1f;	vec3 Ambient = occ*vec3(1,1,1)*AmbientFact;	vec3 DiffColor = texture(texSampler, fragTexCoord).rgb;	if(fragPos.y>2.8-5){		DiffColor *= vec3(0.98,0.2,0);	}	float AmbFact = 0.01f;	vec3 Diffuse = Lambert_Diffuse_BRDF(leftLightDir, Norm, EyeDir, DiffColor) * leftLightColor;	Diffuse += Lambert_Diffuse_BRDF(rightLightDir, Norm, EyeDir, DiffColor) * rightLightColor;	Diffuse += Lambert_Diffuse_BRDF(gubo.lightDir, Norm, EyeDir, DiffColor) * gubo.lightColor.rgb;	Ambient = AmbFact * DiffColor;	//outColor =vec4(Norm, 1.0f);	outColor =vec4(Diffuse + Ambient, 1.0f);	//outColor = vec4(0,fragPos.y/3.8f,0,1);//	outColor = vec4(texture(texSampler, fragTexCoord).rgb * gubo.lightColor.rgb * (max(dot(Norm, gubo.lightDir),0.0f) * 0.9f + 0.1f), 1.0f);//	outColor = vec4(texture(texSampler, fragTexCoord).rgb * (max(dot(Norm, gubo.lightDir),0.0f) * 0.9f + 0.1f), 1.0f);//	outColor = vec4(vec3(max(dot(Norm, gubo.lightDir),0.0f) * 0.85f + 0.15f), 1.0f);//	outColor = vec4(10.0f,1.0f,0.0f,0.0f);		const vec4 fogColor = vec4(0.47, 0.5, 0.67, 0.0);	vec4 color  = mix(outColor, fogColor, fog(0.55));	outColor = vec4(outColor.xyz, 1.0);}